Файл: /c/Users/Fasci/PycharmProjects/lazy-lecture/api/source/app/auth/__init__.py
Содержимое:

------------------------------------

Пропускаем файл (недопустимое расширение): /c/Users/Fasci/PycharmProjects/lazy-lecture/api/source/app/auth/all_files.txt
Файл: /c/Users/Fasci/PycharmProjects/lazy-lecture/api/source/app/auth/auth.py
Содержимое:
from typing import Annotated

from fastapi import Depends

from source.app.auth.services import auth, auth_admin, auth_can_interact
from source.app.users.models import User

CurrentUser = Annotated[User, Depends(auth)]
CanInteractCurrentUser = Annotated[User, Depends(auth_can_interact)]
Admin = Annotated[User, Depends(auth_admin)]

# # TODO: worker class
# Worker = Annotated[]

------------------------------------

Файл: /c/Users/Fasci/PycharmProjects/lazy-lecture/api/source/app/auth/enums.py
Содержимое:
from enum import Enum


class TokenType(str, Enum):
    ACCESS = "access"
    REFRESH = "refresh"

------------------------------------

Файл: /c/Users/Fasci/PycharmProjects/lazy-lecture/api/source/app/auth/schemas.py
Содержимое:
from pydantic import BaseModel

from source.app.auth.types import UsernameStr, PasswordStr


class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"


class Credentials(BaseModel):
    username: UsernameStr
    password: PasswordStr


class Refresh(BaseModel):
    refresh_token: str

------------------------------------

Файл: /c/Users/Fasci/PycharmProjects/lazy-lecture/api/source/app/auth/services.py
Содержимое:
from datetime import datetime, timedelta, timezone

from fastapi import Depends, Security
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from jose import ExpiredSignatureError, JWTError, jwt
from jose.exceptions import JWTClaimsError
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from source.app.auth.enums import TokenType
from source.app.auth.utils import verify_password
from source.app.users.enums import Roles
from source.app.users.models import User
from source.core.database import get_db
from source.core.exceptions import forbidden, unauthorized
from source.core.settings import settings


async def validate_user(user: User) -> User:
    if not user.active:
        return unauthorized("Your account is blocked")
    return user


async def authenticate_user(username: str, password: str, db: AsyncSession) -> User | None:
    user = await db.scalar(select(User).filter_by(username=username))
    if user and verify_password(plain_password=password, hashed_password=user.password):
        return await validate_user(user=user)
    return None


async def authenticate_token(
    user_id: int,
    password_timestamp: float,
    db: AsyncSession,
) -> User | None:
    user: User | None = await db.get(User, user_id)
    if user and password_timestamp == user.password_timestamp:
        return await validate_user(user=user)
    return None


async def generate_token(
    user_id: int,
    password_timestamp: float,
) -> dict:
    access = {
        "user_id": user_id,
        "password_timestamp": password_timestamp,
        "exp": datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES),
        "token_type": TokenType.ACCESS,
    }
    refresh = access.copy()
    refresh.update(
        {
            "exp": datetime.now(timezone.utc) + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS),
            "token_type": TokenType.REFRESH,
        }
    )
    access_token = jwt.encode(access, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    refresh_token = jwt.encode(refresh, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
    }


async def decode_token(token: str) -> dict:
    try:
        return jwt.decode(token, settings.SECRET_KEY, algorithms=settings.ALGORITHM)
    except (JWTError, ExpiredSignatureError, JWTClaimsError):
        return {}


async def authenticate_access_token(
    token: str, db: AsyncSession, roles: list | None = None, can_interact: bool | None = None
) -> User | None:
    payload = await decode_token(token)
    if payload and payload.get("token_type") == TokenType.ACCESS:
        if user := await authenticate_token(
            user_id=payload["user_id"],
            password_timestamp=payload["password_timestamp"],
            db=db,
        ):
            correct_role = roles is None or user.role in roles
            correct_can_interact = can_interact is None or user.can_interact == can_interact
            is_good = correct_role and correct_can_interact
            if is_good:
                return user
            else:
                return forbidden(f"Access restricted. Either your role or can_interact is invalid for the action.")
    return None


async def authenticate_refresh_token(token: str, db: AsyncSession) -> dict | None:
    payload = await decode_token(token)
    if payload and payload.get("token_type") == TokenType.REFRESH:
        if user := await authenticate_token(
            user_id=payload["user_id"],
            password_timestamp=payload["password_timestamp"],
            db=db,
        ):
            return await generate_token(
                user_id=user.id,
                password_timestamp=user.password_timestamp,
            )
    return None


async def authenticate(
    token: str, db: AsyncSession, roles: list | None = None, can_interact: bool | None = None
) -> User:
    if user := await authenticate_access_token(token=token, roles=roles, db=db, can_interact=can_interact):
        return user
    return unauthorized("Invalid or expired token")


async def auth(
    token: HTTPAuthorizationCredentials = Security(HTTPBearer(auto_error=False)),
    db: AsyncSession = Depends(get_db),
) -> User:
    if not token:
        return unauthorized("Invalid Authorization Header")
    return await authenticate(token=token.credentials, db=db)


async def auth_admin(
    token: HTTPAuthorizationCredentials = Security(HTTPBearer(auto_error=False)),
    db: AsyncSession = Depends(get_db),
) -> User:
    if not token:
        return unauthorized("Invalid Authorization Header")
    return await authenticate(token=token.credentials, db=db, roles=[Roles.ADMIN.value])


async def auth_can_interact(
    token: HTTPAuthorizationCredentials = Security(HTTPBearer(auto_error=False)),
    db: AsyncSession = Depends(get_db),
) -> User:
    if not token:
        return unauthorized("Invalid Authorization Header")
    return await authenticate(token=token.credentials, db=db, can_interact=True)

------------------------------------

Файл: /c/Users/Fasci/PycharmProjects/lazy-lecture/api/source/app/auth/types.py
Содержимое:
import re
import typing as tp
from typing_extensions import Annotated
from pydantic import (
    AfterValidator,
    PlainSerializer,
    TypeAdapter,
    WithJsonSchema,
)


def validate_username(value: str) -> str:
    # ft 1-5
    check_latin = re.fullmatch(r"[A-Za-z]+", value) is not None
    check_length = 5 <= len(value) <= 64

    if not all([check_latin, check_length]):
        raise ValueError("Username must consist of Latin letters only and be between 5 and 64 characters long.")
    return value


def validate_pass(value: str) -> str:
    # ft 1-4
    check_len = 256 >= len(value) >= 8
    check_latin = re.search(r"[A-Za-z]", value) is not None
    check_upper_lower = re.search(r"[A-Z]", value) and re.search(r"[a-z]", value)
    check_numbers = re.search(r"\d", value) is not None
    check_special = re.search(r'[!@#$%^&*(),.?":{}|<>=_]', value) is not None

    if not all([check_len, check_latin, check_upper_lower, check_numbers, check_special]):
        raise ValueError(
            "Password must be 8-256 characters long, include Latin letters (uppercase and lowercase), "
            "numbers, and at least one special character."
        )
    return value


PasswordStr = Annotated[
    str,
    AfterValidator(validate_pass),
    PlainSerializer(lambda x: str(x), return_type=str),
    WithJsonSchema({"type": "string"}, mode="serialization"),
]
UsernameStr = Annotated[
    str,
    AfterValidator(validate_username),
    PlainSerializer(lambda x: str(x), return_type=str),
    WithJsonSchema({"type": "string"}, mode="serialization"),
]

------------------------------------

Файл: /c/Users/Fasci/PycharmProjects/lazy-lecture/api/source/app/auth/utils.py
Содержимое:
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

------------------------------------

Файл: /c/Users/Fasci/PycharmProjects/lazy-lecture/api/source/app/auth/views.py
Содержимое:
from fastapi import APIRouter, Depends, status
from sqlalchemy.ext.asyncio import AsyncSession

from source.app.auth.schemas import Credentials, Refresh, Token
from source.app.auth.services import (
    authenticate_refresh_token,
    authenticate_user,
    generate_token,
)
from source.core.database import get_db
from source.core.exceptions import unauthorized
from source.core.schemas import ExceptionSchema

auth_router = APIRouter(prefix="/auth", tags=["auth"])


@auth_router.post(
    "/login",
    response_model=Token,
    responses={status.HTTP_401_UNAUTHORIZED: {"model": ExceptionSchema}},
)
async def token(credentials: Credentials, db: AsyncSession = Depends(get_db)) -> dict:
    if user := await authenticate_user(
        username=credentials.username,
        password=credentials.password,
        db=db,
    ):
        return await generate_token(user_id=user.id, password_timestamp=user.password_timestamp)
    return unauthorized("Incorrect username or password")


@auth_router.post(
    "/refresh",
    response_model=Token,
    responses={status.HTTP_401_UNAUTHORIZED: {"model": ExceptionSchema}},
)
async def refresh(request: Refresh, db: AsyncSession = Depends(get_db)) -> dict:
    if new_token := await authenticate_refresh_token(token=request.refresh_token, db=db):
        return new_token
    return unauthorized("Invalid or expired token")

------------------------------------
